<?xml version='1.0'?>
<robot name="walli" xmlns:xacro="http://www.ros.org/wiki/xacro">
  <xacro:include filename="walli_prop.xacro"/>
  <xacro:include filename="walli_inertials.xacro"/>
  <xacro:include filename="$(find velodyne_description)/urdf/VLP-16.urdf.xacro"/>
  <xacro:include filename="walliArmV3.urdf"/>
  
  <!-- Rover Base Link -->
  <link name="base_link">
    <visual>
      <geometry>
        <box size="${base_length} ${base_width} ${base_height}"/>
      </geometry>
      <material name="Cyan">
        <color rgba="0 1.0 1.0 1.0"/>
      </material>
    </visual>
    <collision>
      <geometry>
        <box size="${base_length} ${base_width} ${base_height}"/>
      </geometry>
    </collision>
    <xacro:box_inertia m="15" w="${base_width}" d="${base_length}" h="${base_height}"/>
  </link>
  <gazebo reference="base_link">
    <material>Gazebo/Red</material>
  </gazebo>
  

  <!-- Wheels -->
  <xacro:macro name="wheel" params="prefix x_reflect y_reflect">
    <link name="${prefix}_link">
      <visual>
        <origin xyz="0 0 0" rpy="${pi/2} 0 0" />
        <geometry>
          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>
        </geometry>
        <material name="Gray">
          <color rgba="0.5 0.5 0.5 1.0"/>
        </material>
      </visual>
      <collision>
        <origin xyz="0 0 0" rpy="${pi/2} 0 0"/>
        <geometry>
          <cylinder radius="${wheel_radius}" length="${wheel_width}"/>
        </geometry>
      </collision>
      <xacro:cylinder_inertia m="0.5" r="${wheel_radius}" h="${wheel_width}"/>
    </link>
    <joint name="${prefix}_joint" type="continuous">
      <parent link="base_link"/>
      <child link="${prefix}_link"/>
      <origin xyz="${x_reflect*wheel_xoff} ${y_reflect*(base_width/2+wheel_ygap)} ${-wheel_zoff}" rpy="0 0 0"/>
      <axis xyz="0 1 0"/>
      <limit effort="${axle_eff_limit}" velocity="${axle_vel_limit}"/>
      <dynamics damping="0" friction="4.0" />
    </joint>
    <gazebo reference="${prefix}_link">
      <material>Gazebo/Black</material>
    </gazebo>
  </xacro:macro>
  <xacro:wheel prefix="left_front_wheel"   x_reflect="1" y_reflect="-1"/>
  <xacro:wheel prefix="left_center_wheel"  x_reflect="0" y_reflect="-1"/>
  <xacro:wheel prefix="left_rear_wheel"    x_reflect="-1" y_reflect="-1"/>
  <xacro:wheel prefix="right_front_wheel"  x_reflect="1" y_reflect="1"/>
  <xacro:wheel prefix="right_center_wheel" x_reflect="0" y_reflect="1"/>
  <xacro:wheel prefix="right_rear_wheel"   x_reflect="-1" y_reflect="1"/>

  <!-- Robot Footprint -->
  <link name="base_footprint"/>
  <joint name="base_joint" type="fixed">
    <parent link="base_link"/>
    <child link="base_footprint"/>
    <origin xyz="0.0 0.0 ${-(wheel_radius+wheel_zoff)}" rpy="0 0 0"/>
  </joint>
  
  <!-- Arm Joint -->
  <joint name="arm_to_rover" type="fixed">
    <origin rpy="0 0 0" xyz="0 0 0"/>
    <parent link="base_link"/>
    <child link="arm_base_link"/>
    <dynamics damping="60.0" friction="4.0"/>
  </joint>

  <!-- IMU -->
  <link name="imu_link">
    <visual>
      <geometry>
        <box size="0.1 0.1 0.1"/>
      </geometry>
    </visual>
    <collision>
      <geometry>
        <box size="0.1 0.1 0.1"/>
      </geometry>
    </collision>
    <xacro:box_inertia m="0.1" w="0.1" d="0.1" h="0.1"/>
  </link>
  <joint name="imu_joint" type="fixed">
		<axis xyz="1 0 0"/>
		<origin xyz="0 0 0.05"/>
		<parent link="base_link"/>
		<child link="imu_link"/>
	</joint>
	<gazebo reference="imu_link">
    <sensor name="imu_sensor" type="imu">
      <plugin filename="libgazebo_ros_imu_sensor.so" name="imu_plugin">
        <ros>
          <namespace>/imu</namespace>
          <remapping>~/out:=data</remapping>
        </ros>
        <initial_orientation_as_reference>false</initial_orientation_as_reference>
      </plugin>
      <always_on>true</always_on>
      <update_rate>100</update_rate>
      <visualize>true</visualize>
     <imu>
     	<angular_velocity>
     	  <x>
     	    <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>2e-4</stddev>
              <bias_mean>0.0000075</bias_mean>
              <bias_stddev>0.0000008</bias_stddev>
            </noise>
          </x>
          <y>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>2e-4</stddev>
              <bias_mean>0.0000075</bias_mean>
              <bias_stddev>0.0000008</bias_stddev>
            </noise>
          </y>
          <z>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>2e-4</stddev>
              <bias_mean>0.0000075</bias_mean>
              <bias_stddev>0.0000008</bias_stddev>
            </noise>
          </z>
        </angular_velocity>
        <linear_acceleration>
          <x>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>1.7e-2</stddev>
              <bias_mean>0.1</bias_mean>
              <bias_stddev>0.001</bias_stddev>
            </noise>
          </x>
          <y>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>1.7e-2</stddev>
              <bias_mean>0.1</bias_mean>
              <bias_stddev>0.001</bias_stddev>
            </noise>
          </y>
          <z>
            <noise type="gaussian">
              <mean>0.0</mean>
              <stddev>1.7e-2</stddev>
              <bias_mean>0.1</bias_mean>
              <bias_stddev>0.001</bias_stddev>
            </noise>
          </z>
        </linear_acceleration>
      </imu>
    </sensor>
  </gazebo>


  <gazebo>
  <plugin name='diff_drive' filename='libgazebo_ros_diff_drive.so'>
    <ros>
      <namespace>/sensor</namespace>
    </ros>
    <!-- wheels -->
    <left_joint>left_front_wheel_joint</left_joint>
    <right_joint>right_front_wheel_joint</right_joint>
    <!-- kinematics -->
    <wheel_separation>0.4</wheel_separation>
    <wheel_diameter>0.2</wheel_diameter>
    <!-- limits -->
    <max_wheel_torque>20</max_wheel_torque>
    <max_wheel_acceleration>1.0</max_wheel_acceleration>
    <!-- output -->
    <publish_odom>true</publish_odom>
    <publish_odom_tf>false</publish_odom_tf>
    <publish_wheel_tf>true</publish_wheel_tf>
    <odometry_frame>odom</odometry_frame>
    <robot_base_frame>base_link</robot_base_frame>
  </plugin>
</gazebo>

  <!-- GPS -->
  <link name="gps">
    <visual>
      <geometry>
        <box size="0.1 0.1 0.1"/>
      </geometry>
    </visual>
    <collision>
      <geometry>
        <box size="0.1 0.1 0.1"/>
      </geometry>
    </collision>
    <xacro:box_inertia m="0.1" w="0.1" d="0.1" h="0.1"/>
  </link>
   <joint name="gps_joint" type="fixed">
		<axis xyz="1 0 0"/>
		<origin xyz="0 0 0.05"/>
		<parent link="base_link"/>
		<child link="gps"/>
	</joint>
  <gazebo reference="gps">
    <sensor name="gps" type="gps">
      <plugin filename="libgazebo_ros_gps_sensor.so" name="gps_plugin">
          <ros>
            <namespace>/gps</namespace>
            <remapping>~/out:=data</remapping>
          </ros>
          <frame_name>gps</frame_name>
        </plugin>
        <always_on>true</always_on>
        <updateRate>30</updateRate>
    </sensor>
  </gazebo>

   <!-- LIDAR -->
   <link name="lidar_support">
      <visual>
          <geometry>
              <box size="${lidar_support_x_dim} ${lidar_support_y_dim} ${lidar_support_z_dim}"/>
          </geometry>
      </visual>
    </link>
    <joint name="base_link_to_lidar_support" type="fixed">
        <parent link="base_link"/>
        <child link="lidar_support"/>
        <origin xyz="0.0 0.0 0.0" rpy="0.0 0.0 0.0"/>
    </joint>
    <!-- collision range = min sensing distance -->
    <!-- gpu does gpu acceleration -->
    <xacro:VLP-16 parent="lidar_support" name="lidar" topic="/scan" hz="${lidar_hz}" samples="${lidar_samples}" gpu="false">
        <origin xyz="${lidar_x} 0.0 ${lidar_z}" rpy="0 ${lidar_pitch} 0" />
    </xacro:VLP-16>



  <xacro:macro name="camera" params="orientation origin_x origin_y origin_z yaw">
    <link name="cam/${orientation}">
      <visual>
        <geometry>
          <box size="0.01 0.01 0.01"/>
        </geometry>
      </visual>
      <collision>
        <geometry>
          <box size="0.01 0.01 0.01"/>
        </geometry>
      </collision>
      <xacro:box_inertia m="0.01" w="0.01" d="0.01" h="0.01"/>
    </link>
    <joint name="${orientation}_cam_joint" type="fixed">
  	  <axis xyz="1 0 0"/>
      <!-- Camera Orientation-->
	    <origin xyz="${origin_x} ${origin_y} ${origin_z}" rpy = "0 0 ${yaw}"/>
	    <parent link="base_link"/>
	    <child link="cam/${orientation}"/>
    </joint>
    <gazebo reference="cam/${orientation}">
      <sensor name="${orientation}_sensor" type="camera">
        <plugin name="${orientation}_sensor" filename="libgazebo_ros_camera.so">
          <ros>
            <namespace>/image</namespace>
            <remapping>~/image_raw:=${orientation}_img</remapping>
            <remapping>~/camera_info:=${orientation}_camera_info</remapping>
          </ros>
          <initial_orientation_as_reference>false</initial_orientation_as_reference>
          <camera_name>${orientation}_camera</camera_name>
          <frame_name>${orientation}_tf</frame_name>
          <hack_baseline>0.07</hack_baseline>
        </plugin>
        <always_on>true</always_on>
        <update_rate>100</update_rate>
        <visualize>true</visualize>
        <camera name="cam/${orientation}">
          <horizontal_fov>1.3962634</horizontal_fov>
          <image>
            <width>800</width>
            <height>800</height>
            <format>R8G8B8</format>
          </image>
          <clip>
            <near>0.02</near>
            <far>300</far>
          </clip>
          <noise>
            <type>gaussian</type>
            <mean>0</mean>
            <stddev>0.007</stddev>
          </noise>
        </camera>
      </sensor>
    </gazebo>
  </xacro:macro>
  <xacro:camera orientation="center" origin_x="0.15" origin_y="0"    origin_z="-0.1" yaw="-0.14"/>
  <xacro:camera orientation="left"   origin_x="0"    origin_y="0.1"  origin_z="0"    yaw="1.5"/>
  <xacro:camera orientation="right"  origin_x="0"    origin_y="-0.1" origin_z="0"    yaw="-1.5"/>
    
  <gazebo>
    <sensor name="imu" type="imu">
      <always_on>true</always_on>
      <update_rate>30</update_rate>
      <plugin name="imu" filename="libgazebo_ros_imu_sensor.so">
        <ros>
          <namespace>/imu</namespace>
          <argument>~/out:=data</argument>
        </ros>
        <frame_name>imu</frame_name>
      </plugin>
    </sensor>            
    <plugin name="gazebo_ros_p3d" filename="libgazebo_ros_p3d.so">
      <alwaysOn>true</alwaysOn>
      <update_rate>30.0</update_rate>
      <ros>
        <namespace>/ground_truth</namespace>
        <remapping>odom:=state_raw</remapping>
      </ros>
      <body_name>base_link</body_name>
      <frame_name>world</frame_name>

      <xyz_offset>0 0 0</xyz_offset>
      <rpy_offset>0.0 0.0 0.0</rpy_offset>
      <gaussian_noise>0.00</gaussian_noise>
    </plugin>
  </gazebo>

</robot>

    <!-- Mock/Untested ros2 control scheme for operating the rover with ros2 control.
    This matches how the control is supposed to be set up, but is commented out
    because the way the urdf is designed, it interferes with the arm control. -->
    <!--
    <ros2_control name="rover_control" type="system">
    <hardware>
      <plugin>ros2_control_demo_hardware/VelocityActuatorHardware</plugin>
    </hardware>
    <joint name="left_bogie_front_axle">
      <command_interface name="velocity">
        <param name="min">-1</param>
        <param name="max">1</param>
      </command_interface>
      <state_interface name="velocity"/>
    </joint>
    <joint name="left_bogie_rear_axle">
      <command_interface name="velocity">
        <param name="min">-1</param>
        <param name="max">1</param>
      </command_interface>
      <state_interface name="velocity"/>
    </joint>
    <joint name="left_rocker_rear_axle">
      <command_interface name="velocity">
        <param name="min">-1</param>
        <param name="max">1</param>
      </command_interface>
      <state_interface name="velocity"/>
    </joint>
    <joint name="right_bogie_front_axle">
      <command_interface name="velocity">
        <param name="min">-1</param>
        <param name="max">1</param>
      </command_interface>
      <state_interface name="velocity"/>
    </joint>
    <joint name="right_bogie_rear_axle">
      <command_interface name="velocity">
        <param name="min">-1</param>
        <param name="max">1</param>
      </command_interface>
      <state_interface name="velocity"/>
    </joint>
    <joint name="right_rocker_rear_axle">
      <command_interface name="velocity">
        <param name="min">-1</param>
        <param name="max">1</param>
      </command_interface>
      <state_interface name="velocity"/>
    </joint>
    <transmission name="rover_transmission">
      <plugin>transmission_interface/SimpleTransmission</plugin>
      <joint name="left_bogie_front_axle" role="left_bogie_front_axle">
        <mechanical_reduction>1</mechanical_reduction>
      </joint>
      <joint name="left_bogie_rear_axle" role="left_bogie_rear_axle">
        <mechanical_reduction>1</mechanical_reduction>
      </joint>
      <joint name="left_rocker_rear_axle" role="left_rocker_rear_axle">
        <mechanical_reduction>1</mechanical_reduction>
      </joint>
      <joint name="right_bogie_front_axle" role="right_bogie_front_axle">
        <mechanical_reduction>1</mechanical_reduction>
      </joint>
      <joint name="right_bogie_rear_axle" role="right_bogie_rear_axle">
        <mechanical_reduction>1</mechanical_reduction>
      </joint>
      <joint name="right_rocker_rear_axle" role="right_rocket_rear_axle">
        <mechanical_reduction>1</mechanical_reduction>
      </joint>
    </transmission>
    </ros2_control>
    -->